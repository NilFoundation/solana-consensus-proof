\section{Verification Logic API Reference}

Every call to Placeholder public API verification function eventually leads to a call of internal verification function for chosen circuit
    (for example, \url{https://github.com/NilFoundation/evm-placeholder-verification/blob/7672050e4bcdc9e98f90ddda8a85f7c81d0ecc14/contracts/placeholder/verifier_unified_addition_component.sol#L66}). 
These internal verification functions should be supplied with proof byteblob and initialized verification parameters.

For now there is test public API which execute basic logic consisting of:
\begin{enumerate}
    \item parsing proof byteblob
    \item verification parameters initialization
    \item circuit specific internal verification function calling
    \item verification result returning
\end{enumerate}

Example of test public API function declaration intended for verification of unified addition circuit
 (see \url{https://github.com/NilFoundation/evm-placeholder-verification/blob/7672050e4bcdc9e98f90ddda8a85f7c81d0ecc14/contracts/placeholder/test/public_api_placeholder_unified_addition_component.sol#L34}):

\begin{verbatim}
function verify(
    bytes calldata blob,
    uint256[] calldata init_params,
    int256[][] calldata columns_rotations
) public {...}
\end{verbatim}

More details regarding public API input data structure see in the next section.

Other existing test public API functions could be found here:
\begin{itemize}
    \item \url{https://github.com/NilFoundation/evm-placeholder-verification/blob/7672050e4bcdc9e98f90ddda8a85f7c81d0ecc14/contracts/placeholder/test/public_api_placeholder_non_native_field_add_component.sol#L34}
    \item \url{https://github.com/NilFoundation/evm-placeholder-verification/blob/7672050e4bcdc9e98f90ddda8a85f7c81d0ecc14/contracts/placeholder/test/public_api_placeholder_variable_base_scalar_mul_component.sol#L34}
\end{itemize}
